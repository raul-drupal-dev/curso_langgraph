# ðŸŽ¯ Tema 2: Edges (Conexiones)

## ðŸ§© Â¿QuÃ© son los Edges?  
Los **edges** son las conexiones entre nodos que dirigen el flujo de datos de un nodo a otro. Estas conexiones pueden ser:  

- **Directas:** Conectan un nodo con el siguiente sin condiciones.  
- **Condicionales:** Deciden dinÃ¡micamente quÃ© nodo visitar a continuaciÃ³n basÃ¡ndose en una funciÃ³n lÃ³gica.  

En este ejemplo, utilizaremos un flujo de decisiÃ³n aleatorio para mostrar cÃ³mo se pueden agregar edges y bifurcaciones.  

---

## ðŸ› ï¸ Ejemplo PrÃ¡ctico: Construyendo un Grafo con Edges  

Usando el codigo usado anteriormente con nos lodos, mostramos el cÃ³digo de ejemplo que ilustra cÃ³mo agregar edges entre nodos:  

```python
def node_1(state):
    print("---Node 1---")
    return {"graph_state": state['graph_state'] + " Me gusta"}

def node_2(state):
    print("---Node 2---")
    return {"graph_state": state['graph_state'] + " programar!"}

def node_3(state):
    print("---Node 3---")
    return {"graph_state": state['graph_state'] + " salir en bici!"}
```

---

### ðŸ” ExplicaciÃ³n Paso a Paso  

#### ðŸ“Œ DefiniciÃ³n de Nodos  

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)
```

- **`node_1`**: AÃ±ade al estado `"Me gusta"`.  
- **`node_2`**: AÃ±ade al estado `"programar!"`.  
- **`node_3`**: AÃ±ade al estado `"salir en bici!"`.  

En este caso, `node_1` actÃºa como punto de partida para las decisiones que se tomarÃ¡n posteriormente.  

---

#### ðŸ”„ DecisiÃ³n con Condiciones  

```python
import random
from typing import Literal

def decide_hooby(state) -> Literal["node_2", "node_3"]:
    if random.random() < 0.5:
        return "node_2"
    return "node_3"
``` 


La funciÃ³n `decide_hooby` decide, de forma aleatoria, si el flujo debe continuar hacia `node_2` o `node_3`.  

- **50%** de probabilidad de ir a `node_2` (programar).  
- **50%** de probabilidad de ir a `node_3` (salir en bici).  

Este edge condicional permite que el grafo tenga mÃºltiples rutas de ejecuciÃ³n.  

---

#### ðŸ—ï¸ ConstrucciÃ³n del Grafo  

```python
builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_hooby)
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)
```  

- **`add_edge`**: Conecta directamente `START` con `node_1`.  
- **`add_conditional_edges`**: Desde `node_1`, el flujo se bifurca condicionalmente hacia `node_2` o `node_3`.  
- **`add_edge` (Final)**: Ambos nodos (`node_2` y `node_3`) terminan en el nodo final `END`.  

---

### ðŸ“ˆ Visualizando el Grafo  

Una vez construido, podemos visualizar el grafo:  

```python
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
``` 

---

## âš™ï¸ Invocando el Grafo  

Para ejecutar el grafo y ver su comportamiento, utilizamos:  

```python
graph.invoke({"graph_state" : "Hola, me llamo Raul."})
```



