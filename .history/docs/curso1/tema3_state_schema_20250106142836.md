# 🧩 Tema 3: State Schema y Memoria  

## 🚀 ¿Qué es el State Schema y la Memoria en LangGraph?  

El **State Schema** es una parte fundamental de LangGraph que nos permite definir y gestionar el estado del grafo mientras se ejecuta.  
El estado es la información que se **mantiene, actualiza y transfiere** a medida que el flujo pasa por diferentes nodos.  

La memoria nos permite:  
- **Persistencia de datos** a lo largo del flujo.  
- **Decisiones basadas en el estado actual**.  
- **Mayor control** sobre cómo se modifica la información.  

Piensa en el estado como una mochila que lleva información de un nodo a otro, y en cada nodo puedes **añadir, modificar o eliminar** elementos dentro de esa mochila.  

---

## 🛠️ Ejemplo Práctico: Implementando State Schema y Memoria  

A continuación, construiremos un ejemplo simple que muestra cómo definir un `State Schema` y cómo los nodos modifican el estado paso a paso.  

### 📋 Definición del State Schema  
Primero, creamos una estructura básica para nuestro estado utilizando `TypedDict`.  
[codigo1]  

---

### 🧩 Creación de Nodos para Modificar el Estado  
Definimos tres nodos:  
- **Nodo 1**: Añade `"Estoy aprendiendo"` al estado.  
- **Nodo 2**: Agrega `" LangGraph!"`.  
- **Nodo 3**: Añade `" Python es increíble!"` en función de una decisión aleatoria.  

Cada nodo toma el estado actual y lo modifica según una lógica simple.  
[codigo2]  

---

### 🔄 Decisión Condicional  
Implementamos una función que decide entre el **Nodo 2** o el **Nodo 3**, añadiendo una bifurcación condicional.  
[codigo3]  

---

### 🏗️ Construcción del Grafo  
Agregamos los nodos y edges necesarios para construir el grafo, conectando `START` con `node_1`, seguido de una bifurcación hacia `node_2` o `node_3`, y terminando en `END`.  
[codigo4]  

---

### 📈 Visualización del Grafo  
Para entender mejor la estructura creada, visualizamos el grafo.  
[codigo5]  

---

## 🚀 Invocando el Grafo y Posibles Resultados  

Invocamos el grafo pasando un estado inicial.  

```python
graph.invoke({"graph_state" : "Hola!"})
````

Dependiendo de la bifurcación, podemos obtener diferentes resultados:

```phyton title="Resultado 1"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. Me gusta programar!'}
```
```phyton title="Resultado 2"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. Me gusta salir en bici!'}
```

## 🧩 ¿Qué Hemos Aprendido?  

- **State Schema:** Define la estructura del estado que se mantiene a lo largo del flujo del grafo.  
- **Edges Condicionales:** Permiten bifurcaciones en el flujo, tomando decisiones dinámicas que afectan el camino que sigue el grafo.  
- **Flujo de Trabajo Dinámico:** Al conectar nodos de forma condicional, podemos crear grafos más complejos y adaptativos, generando diferentes resultados según la lógica aplicada.  
- **Construcción de Grafos:** Hemos aprendido a agregar nodos, edges y compilar el grafo usando `StateGraph` y `add_edge`.  

---