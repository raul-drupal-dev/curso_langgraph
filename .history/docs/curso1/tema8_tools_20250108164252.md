# 🛠️ Tema 7: Tools – Integración de Herramientas Externas en el Grafo  

## 🚀 ¿Qué son las Tools en LangGraph?  

Las **tools (herramientas)** son funciones externas que el grafo puede invocar para realizar tareas específicas, como consultas a bases de datos, cálculos matemáticos o llamadas a APIs externas.  
Las tools permiten que el grafo **extienda sus capacidades más allá de los nodos internos**, integrando lógica personalizada o servicios de terceros.  

---

### 🧠 ¿Por qué son Importantes las Tools?  

- **Extensibilidad:** Permiten que el grafo interactúe con APIs externas y sistemas avanzados.  
- **Modularidad:** Las tools se definen de forma independiente y se integran fácilmente en el flujo del grafo.  
- **Eficiencia:** Delegan tareas específicas a funciones externas, reduciendo la complejidad dentro de los nodos.  

👉 **Piensa en las tools como plugins** que añaden nuevas capacidades al grafo sin necesidad de modificar su estructura central.  

---

## ⚙️ ¿Cómo Funcionan las Tools?  

1. **Definición de Tools:** Creamos funciones externas que pueden recibir parámetros y devolver resultados.  
2. **Vinculación al Modelo de Lenguaje (LLM):** Asociamos estas tools al LLM para que pueda invocarlas durante el flujo de trabajo.  
3. **Ejecución Condicional:** Si el LLM detecta que es necesario usar una tool, el grafo redirige el flujo para ejecutarla y procesar el resultado.  

💡 Es importante entender que es **el LLM quien decide que tool invocar** dependiendo del prompt que hayamos generado.

---

## 📋 Ejemplo Práctico: Chatbot con Tools para Soporte y Ventas  

Vamos a construir un grafo que actúa como un asistente virtual, redirigiendo solicitudes de los usuarios a diferentes herramientas según sus necesidades.  
El chatbot podrá:  
1. **Consultar precios de productos.**  
2. **Verificar el estado de pedidos.**  
3. **Abrir tickets de soporte.**  

```python
from langchain_openai import ChatOpenAI

# Definimos las tools externas
def check_price(product: str) -> str:
    return f"El precio de {product} es de 100€."

def order_status(order_id: int) -> str:
    return f"El pedido con ID {order_id} está en camino."

def open_ticket(issue: str) -> str:
    return f"Se ha abierto un ticket de soporte para el problema: {issue}."

tools = [check_price, order_status, open_ticket]

# Vinculamos las tools al modelo de lenguaje
llm = ChatOpenAI(model="gpt-4o")
llm_with_tools = llm.bind_tools(tools, parallel_tool_calls=False)
```

---

### 🔍 Explicación del Ejemplo:  

- **Tools (`check_price`, `order_status`, `open_ticket`):** Simulan herramientas externas que realizan distintas tareas para ventas y soporte.  
- **Assistant Node:** El nodo principal procesa el mensaje del usuario y decide si debe invocar alguna tool.  
- **Router Condicional:** El flujo se redirige al nodo de tools si se detecta una llamada a alguna de ellas.  

---

## 🏗️ Construcción del Grafo  

Creamos los nodos y edges necesarios para integrar las tools al flujo del grafo.  
[codigo2]  
```python
from langgraph.graph import MessagesState
from langchain_core.messages import HumanMessage, SystemMessage

sys_msg = SystemMessage(content="Eres un asistente de ventas y soporte. Responde usando las herramientas disponibles.")

def assistant(state: MessagesState):
    return {"messages": [llm_with_tools.invoke([sys_msg] + state["messages"])]}

from langgraph.graph import START, StateGraph
from langgraph.prebuilt import tools_condition
from langgraph.prebuilt import ToolNode

builder = StateGraph(MessagesState)

# Añadimos nodos
builder.add_node("assistant", assistant)
builder.add_node("tools", ToolNode(tools))

# Definimos los edges y el flujo del grafo
builder.add_edge(START, "assistant")
builder.add_conditional_edges("assistant", tools_condition)
builder.add_edge("tools", "assistant")

graph_with_tools = builder.compile()
```

---

## 🚀 Invocando el Grafo  

Probamos el grafo enviando un mensaje del usuario para ver cómo se invocan las tools en el flujo.  

```python
from IPython.display import Image, display
display(Image(graph_with_tools.get_graph(xray=True).draw_mermaid_png()))

messages = [HumanMessage(content="Quiero saber el precio del producto X y abrir un ticket de soporte.")]
response = graph_with_tools.invoke({"messages": messages})

for msg in response["messages"]:
    print(msg.content)
```

```python
El precio de producto X es de 100€.
Se ha abierto un ticket de soporte para el problema: Precio de producto X.
```

El chatbot analiza la solicitud, invoca las tools adecuadas y devuelve una respuesta consolidada al usuario.  

---

## 🧑‍🏫 ¿Qué Hemos Aprendido?  

- **Tools:** Permiten extender el grafo con funciones externas que realizan tareas específicas.  
- **Integración con LLM:** Las tools se vinculan directamente al modelo de lenguaje, permitiendo respuestas más avanzadas.  
- **Flujo Dinámico:** El grafo puede invocar tools de forma condicional, adaptándose a las necesidades del usuario.  

---

## 🌐 ¿Qué es lo Siguiente?  

En el próximo tema, profundizaremos en **subgrafos (subgraphs)**, permitiendo que el grafo ejecute flujos complejos de manera modular y jerárquica.  
