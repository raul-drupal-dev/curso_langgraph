# 🧩 Tema 3: State Schema y Memoria  

## 🚀 ¿Qué es el State Schema y la Memoria en LangGraph?  

El **State Schema** es el corazón de LangGraph, ya que define y gestiona el estado del grafo durante su ejecución.  
El **estado** es la información que **se transfiere, modifica y actualiza** a medida que el flujo avanza por diferentes nodos.  

Piensa en el estado como una mochila 🧳 que lleva datos entre los nodos. En cada nodo, puedes:  
- **Añadir** nuevos datos.  
- **Modificar** valores existentes.  
- **Eliminar** información que ya no necesitas.  

### 🧠 ¿Y la Memoria?  
La memoria es la capacidad que tiene el grafo para **recordar información** a lo largo de múltiples invocaciones. Es especialmente útil cuando creamos chatbots o flujos conversacionales donde el contexto es crucial.  

- **Sin memoria:** Cada vez que invocamos el grafo, comienza desde cero.  
- **Con memoria:** El grafo guarda un historial de mensajes o datos, permitiendo respuestas basadas en todo el contexto anterior.  

**¿Por qué es importante?**  
- **Persistencia de datos.**  
- **Toma de decisiones basadas en el contexto actual.**  
- **Mayor precisión en interacciones prolongadas.**  

---

## ⚙️ ¿Cómo Funciona el State?  

Para entender cómo se define el estado en LangGraph, crearemos un `State` personalizado.  
Este enfoque facilita la comprensión antes de utilizar estructuras predefinidas como `MessagesState`.  

### 📋 Creación de un State Propio  
```python
from typing_extensions import TypedDict

class State(TypedDict):
    graph_state: str
```

- **Explicación:**  
  - `TypedDict` nos permite definir un diccionario con tipos estrictos, lo que asegura que el estado tenga una estructura clara y esperada.  
  - El `graph_state` es un campo donde almacenaremos mensajes o datos que pasarán de un nodo a otro.  

Si prefieres simplificar, puedes utilizar el estado predefinido `MessagesState` de LangGraph, diseñado específicamente para flujos conversacionales.  
👉 [Documentación de MessagesState](https://python.langchain.com/docs/modules/langgraph#messagesstate)  

---

## 🧩 Nodos que Utilizan el Estado  

A continuación, crearemos dos nodos que utilizan el estado:  
1. **Nodo de entrada del usuario:** Agrega el mensaje del usuario al estado.  
2. **Nodo de respuesta de IA:** El modelo de OpenAI (`gpt-4o-mini`) genera una respuesta basada en el historial.  

```python  
```

- **`user_input_node:`** Toma el mensaje del usuario y lo guarda en el estado.  
- **`ai_response_node:`** Usa el estado actual (historial) para generar una respuesta de IA.  

---

## 🧠 Memoria: ¿Cómo Funciona?  

LangGraph ofrece varios tipos de memoria:  

1. **Memoria de Estado (State Memory):**  
   - El estado se transfiere de nodo a nodo, reteniendo información solo durante una invocación.  
   
2. **Memoria de Corto Alcance (MemorySaver):**  
   - Guarda datos durante múltiples invocaciones, pero **no persiste después de cerrar el programa.**  
   - Almacena la información en memoria volátil (RAM).  
   - Ideal para flujos temporales que necesitan recordar el contexto durante la sesión actual.  
   👉 [Documentación de MemorySaver](https://python.langchain.com/docs/modules/langgraph#memorysaver)  

3. **Memoria Persistente (Postgres u otros):**  
   - Permite almacenar el historial en bases de datos externas (ej: PostgreSQL).  
   - **Se verá en temas más avanzados.**  

4. **Memoria Transversal (Cross-Session Memory):**  
   - Conserva datos a lo largo de múltiples sesiones y usuarios.  
   - **Se estudiará en profundidad en futuros módulos.**  

---

## 🏗️ Añadiendo Memoria al Grafo  

Ahora implementaremos el `MemorySaver` para agregar memoria de corto alcance a nuestro grafo.  

### 📋 Grafo sin Memoria  
```python  
```
[codigo3]  

### 📋 Grafo con Memoria  
```python  
```
[codigo4]  

---

## 📈 Visualización del Grafo  

Para observar cómo se estructura nuestro grafo, generamos una visualización:  
```python  
```
[codigo5]  

---

## 🚀 Invocando el Grafo y Comparando Resultados  

### 📋 Sin Memoria  
```python  
```
[codigo6]  
```python  
```
[resultado1]  

---

### 📋 Con Memoria  
```python  
```
[codigo7]  
[resultado2]  

---

## 🧑‍🏫 ¿Qué Hemos Aprendido?  

- **State Schema:** Es la estructura que define qué datos se transportan y modifican durante el flujo del grafo.  
- **Memoria de Estado (State):** Solo persiste durante la ejecución de una invocación.  
- **MemorySaver:** Proporciona memoria de corto alcance para retener datos durante múltiples invocaciones.  
- **Diferencias Clave:** Sin memoria, cada invocación es independiente. Con memoria, el grafo recuerda datos anteriores.  

---

## 🌐 ¿Qué es lo Siguiente?  

En el siguiente tema exploraremos **Chains y Flujos de Trabajo**, donde aprenderemos a encadenar nodos y construir pipelines complejos.  
También abordaremos el tema de **Tools (Herramientas)**, pero lo veremos **después de Chains**, ya que comprender primero el flujo de trabajo hará que la integración de herramientas sea más sencilla y práctica.  
