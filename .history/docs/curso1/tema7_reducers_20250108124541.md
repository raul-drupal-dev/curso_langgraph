# 🔄 Tema 6: Reducers

## 🚀 ¿Qué es un Reducer en LangGraph?  

Los **reducers** en LangGraph permiten consolidar y procesar datos provenientes de diferentes nodos o caminos.  
Cuando un grafo sigue **flujos paralelos o múltiples bifurcaciones**, los reducers **recogen, combinan o modifican** los resultados, facilitando una salida coherente y organizada.  

👉 **Piensa en un reducer como un colector de datos** que une los resultados de distintas partes del grafo en un solo punto.  

---

### 🧠 ¿Por qué son Importantes los Reducers?  

- **Consolidación de Datos:** Reúne información de diferentes nodos y la almacena en el estado.  
- **Flujos Complejos:** Permite manejar y combinar respuestas de múltiples caminos paralelos.  
- **Evitan Sobrescrituras No Deseadas:** Sin un reducer, cada actualización sobrescribe el valor existente.  

---

## ⚙️ ¿Cómo Funciona un Reducer?  

Cuando un nodo devuelve datos parciales del estado, el reducer **decide cómo aplicar esos datos**:  
- **Sin Reducer:** El valor existente se **sobrescribe.**  
- **Con Reducer:** Los datos se **combinan o acumulan** siguiendo una lógica definida.  

👉 **Ejemplo:** Si tienes una lista de mensajes, un reducer puede añadir nuevos mensajes al final, en lugar de borrar el historial anterior.  

---

## 🔍 Ejemplo A: Sin Reducer (Sobrescritura Directa)  

En este caso, cada vez que un nodo devuelve un valor, sobrescribe el valor anterior:  

```python
from typing_extensions import TypedDict
from langchain_core.messages import AnyMessage

class State(TypedDict):
    messages: list[AnyMessage]  # Sin reducer (sobrescribe)
    response: str
    department: str
``` 

---

### 🔎 Explicación:  
- La clave `messages` no tiene un reducer asignado.  
- **Cada actualización de mensajes reemplaza por completo la lista anterior.**  
- El último mensaje será el único que quede en el estado.  

---

## 📋 Ejemplo B: Con Reducer (Acumulación de Mensajes)  

Usamos `Annotated` y `add_messages` para acumular mensajes en lugar de sobrescribirlos:  
 
```python
from typing import Annotated
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]  # Con reducer (acumula)
    response: str
    department: str
``` 

- **`Annotated`** permite añadir metadatos a `messages` para definir un reducer.  
- **`add_messages`** acumula mensajes en el historial, evitando sobrescrituras.  
- Cada vez que un nodo añade un mensaje, este se agrega al final de la lista.  

---

## 🛠️ Ejemplo Completo: Comparando con y sin Reducer  

Vamos a construir un grafo de chatbot que:  
1. Recibe el mensaje del usuario.  
2. Redirige al nodo correspondiente (soporte, ventas, general).  
3. Añade respuestas al historial de mensajes usando un reducer.  

Veremos cómo cambia el resultado al usar un reducer para `messages`.  

```python
from langchain_core.messages import HumanMessage, AIMessage

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    state["messages"].append(HumanMessage(content="Hola, tengo una pregunta."))
    return state

def support_node(state: State):
    print("--- Nodo de Soporte Técnico ---")
    state["messages"].append(AIMessage(content="Te estamos transfiriendo a soporte."))
    state["response"] = "Soporte"
    return state

def route_request(state: State) -> str:
    return "support_node"
```  

---

## 🚀 Invocando el Grafo  

Probamos el grafo sin reducer y luego con `add_messages` para observar la diferencia.  

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("support_node", support_node)

builder.add_edge(START, "user_input")
builder.add_edge("user_input", "support_node")
builder.add_edge("support_node", END)

graph = builder.compile()
graph.invoke({"messages": [], "response": "", "department": ""})
``` 

---

### 📊 Resultado Esperado  
[resultado1]  
```python
# Sin reducer (sobrescribe)
{'messages': [AIMessage(content="Te estamos transfiriendo a soporte.")],
 'response': 'Soporte',
 'department': ''}
``` 

- **Sin Reducer:** Solo el último mensaje aparece en el estado.  
- **Con Reducer:** El historial acumula todos los mensajes y respuestas.  

---

## ✨ ¿Cómo Crear un Reducer Personalizado?  

Si necesitas una lógica específica que `add_messages` no cubre, puedes crear tu propio reducer.  

A continuación, definimos un reducer personalizado que **cuenta cuántos mensajes se han procesado** y actualiza el estado con ese total:  

[codigo5]  
```python
``` 

---

## 🚀 Invocación con Reducer Personalizado  

Ejecutamos el grafo y verificamos cómo el estado se actualiza con el número total de mensajes.  
[codigo6] 
```python
```  

---

### 📊 Resultado Esperado  
[resultado2]  
```python
``` 

El estado reflejará tanto el historial de mensajes como el conteo total.  

---

## 🧑‍🏫 ¿Qué Hemos Aprendido?  

- **Reducers:** Controlan cómo se actualiza el estado durante el flujo del grafo.  
- **add_messages:** Permite acumular mensajes, evitando sobrescrituras.  
- **Reducers Personalizados:** Proporcionan flexibilidad para definir cualquier lógica de actualización.  

---

## 🌐 ¿Qué es lo Siguiente?  

En el próximo tema, exploraremos **Tools (Herramientas)**, viendo cómo integrar funciones externas y APIs dentro del grafo para ampliar sus capacidades.  


https://langchain-ai.github.io/langgraph/concepts/low_level/?h=reducers#reducers
