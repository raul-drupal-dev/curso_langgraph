# ğŸš¦ Tema 6: Routers â€“ Dirigiendo el Flujo del Grafo

## ğŸš€ Â¿QuÃ© es un Router en LangGraph?

Los **routers** en LangGraph son nodos especiales que permiten **redirigir el flujo hacia diferentes caminos** en funciÃ³n de condiciones dinÃ¡micas.  
A diferencia de los **edges condicionales**, los routers **centralizan y gestionan mÃºltiples bifurcaciones** desde un solo punto, haciendo que los grafos sean mÃ¡s **modulares, limpios y escalables.**

---

### ğŸ§  Â¿Por quÃ© usar Routers en lugar de Condicionales?

- **CentralizaciÃ³n:** Un solo nodo puede gestionar mÃºltiples caminos, evitando bifurcaciones dispersas.
- **Escalabilidad:** A medida que crecen los caminos posibles, los routers permiten expandir el grafo sin aÃ±adir complejidad.
- **ReutilizaciÃ³n:** Un mismo router puede ser usado en **diferentes partes del grafo.**
- **Legibilidad:** Mantiene el grafo **organizado y fÃ¡cil de seguir.**

ğŸ‘‰ **Piensa en el router como un semÃ¡foro** ğŸš¦ que dirige el trÃ¡fico hacia diferentes carriles en funciÃ³n de las seÃ±ales recibidas.

---

## âš™ï¸ Â¿CÃ³mo Funciona un Router?

Un router funciona tomando una **decisiÃ³n basada en el estado del grafo** o en **parÃ¡metros especÃ­ficos de entrada.**  
Define mÃºltiples caminos posibles y selecciona uno, enviando el flujo hacia el nodo correspondiente.

---

## ğŸ“‹ Ejemplo PrÃ¡ctico: Chatbot con Router de Departamentos

Vamos a crear un chatbot que redirige al usuario a diferentes departamentos segÃºn el tipo de pregunta:

1. **Soporte TÃ©cnico:** Para resolver problemas tÃ©cnicos.
2. **Ventas:** Para consultas de productos o servicios.
3. **Consultas Generales:** Para cualquier otra pregunta.

El router analizarÃ¡ el mensaje del usuario y lo dirigirÃ¡ al nodo adecuado.

```python
from typing_extensions import TypedDict

class State(TypedDict):
    message: str
    response: str

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    print(state["message"])
    return state

def route_request(state: State) -> str:
    message = state["message"].lower()
    if "soporte" in message or "problema" in message:
        return "support_node"
    elif "comprar" in message or "precio" in message:
        return "sales_node"
    else:
        return "general_node"

def support_node(state: State):
    print("--- Nodo de Soporte TÃ©cnico ---")
    state["response"] = "Te estamos transfiriendo a soporte tÃ©cnico."
    return state

def sales_node(state: State):
    print("--- Nodo de Ventas ---")
    state["response"] = "Te conectamos con el equipo de ventas."
    return state

def general_node(state: State):
    print("--- Nodo de Consultas Generales ---")
    state["response"] = "Tu consulta serÃ¡ respondida a la brevedad."
    return state
```

---

### ğŸ” ExplicaciÃ³n del Ejemplo:

- **Nodo 1 (user_input):** Recibe el mensaje del usuario.
- **Router (route_request):** EvalÃºa el mensaje y redirige al nodo correspondiente: `support_node`, `sales_node` o `general_node`.
- **Nodos de Respuesta:** Cada nodo proporciona una respuesta basada en el departamento al que se redirigiÃ³ al usuario.

---

## ğŸ—ï¸ ConstrucciÃ³n del Grafo con Router

Agregamos el router y conectamos cada nodo de respuesta al flujo.

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("support_node", support_node)
builder.add_node("sales_node", sales_node)
builder.add_node("general_node", general_node)

builder.add_edge(START, "user_input")
builder.add_conditional_edges("user_input", route_request)
builder.add_edge("support_node", END)
builder.add_edge("sales_node", END)
builder.add_edge("general_node", END)

graph = builder.compile()
```

---

## ğŸ“ˆ VisualizaciÃ³n del Grafo

Para observar cÃ³mo se estructura nuestro grafo, generamos una visualizaciÃ³n:

```python
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
```

![grafo routers](../assets/img/curso1/tema6/image.png)

---

## ğŸš€ Invocando el Grafo

Probamos el grafo con diferentes entradas para ver cÃ³mo el router dirige el flujo.

```python
graph.invoke({"message": "", "response": ""})
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': 'Quiero comprar un producto', 'response': 'Te conectamos con el equipo de ventas.'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': 'Tengo un problema con mi cuenta', 'response': 'Te estamos transfiriendo a soporte tÃ©cnico.'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': 'Â¿CuÃ¡l es el horario de atenciÃ³n?', 'response': 'Tu consulta serÃ¡ respondida a la brevedad.'}
```

Dependiendo del contenido del mensaje del usuario, el flujo tomarÃ¡ caminos distintos, demostrando el poder y flexibilidad de los routers.

---

## ğŸ› ï¸ Usando "Command" para Modificar el Estado Durante el Enrutamiento

AdemÃ¡s de redirigir el flujo del grafo, LangGraph permite **modificar el estado directamente desde el router** usando **Command**.  
Esto es Ãºtil cuando, ademÃ¡s de dirigir al usuario a un nodo especÃ­fico, queremos **actualizar atributos del estado** sin necesidad de crear nodos adicionales.

---

### ğŸš€ Â¿QuÃ© es un Command en LangGraph?

Un **command** es una instrucciÃ³n que permite realizar dos acciones simultÃ¡neas:

1. **Enrutar el flujo del grafo hacia un nodo especÃ­fico.**
2. **Actualizar o modificar atributos del estado.**

---

### ğŸ§© Â¿Por QuÃ© es Ãštil?

- **OptimizaciÃ³n:** Evita la necesidad de crear nodos adicionales solo para actualizar el estado.
- **Simplicidad:** Mantiene el flujo del grafo mÃ¡s limpio y con menos nodos intermedios.
- **Eficiencia:** Reduce el nÃºmero de pasos y permite que el grafo sea mÃ¡s dinÃ¡mico y reactivo.

---

### ğŸ“‹ Ejemplo PrÃ¡ctico con Command

Modificaremos nuestro chatbot para que, ademÃ¡s de redirigir al usuario a un departamento, **actualice el estado** con un mensaje indicando a quÃ© secciÃ³n fue transferido.

```python hl_lines="2 14 17 19 21"
from typing_extensions import TypedDict, Literal
from langgraph.graph import command

class State(TypedDict):
    message: str
    response: str
    department: str

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    state["message"] = "Necesito soporte tÃ©cnico"
    return state

def route_request(state: State) -> Command[Literal["support_node", "sales_node","general_node"]]:
    message = state["message"].lower()
    if "soporte" in message:
        return command("support_node", department="Soporte TÃ©cnico")
    elif "comprar" in message:
        return command("sales_node", department="Ventas")
    else:
        return command("general_node", department="Consultas Generales")

def support_node(state: State):
    print("--- Nodo de Soporte TÃ©cnico ---")
    state["response"] = "Te estamos transfiriendo a soporte tÃ©cnico."
    return state

def sales_node(state: State):
    print("--- Nodo de Ventas ---")
    state["response"] = "Te conectamos con el equipo de ventas."
    return state

def general_node(state: State):
    print("--- Nodo de Consultas Generales ---")
    state["response"] = "Tu consulta serÃ¡ respondida a la brevedad."
    return state
```

---

### ğŸ” ExplicaciÃ³n del Ejemplo

- **Router con Command:** Ahora, el router no solo dirige el flujo sino que tambiÃ©n **actualiza el estado con el nombre del departamento** seleccionado.
- **ActualizaciÃ³n Directa del Estado:** Esto nos permite **guardar un registro** de a quÃ© nodo fue transferido el usuario, lo que puede ser Ãºtil para anÃ¡lisis o futuros pasos en el flujo.

---

## ğŸš€ Invocando el Grafo

Probamos el grafo para observar cÃ³mo se actualiza el estado durante el enrutamiento.

```python hl_lines="2 14 17 19 21"
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("route_request", route_request)
builder.add_node("support_node", support_node)
builder.add_node("sales_node", sales_node)
builder.add_node("general_node", general_node)

builder.add_edge(START, "user_input")
builder.add_edge("user_input","route_request")
# NOTE: No hay edges entre route_request y el resto de nodos!
builder.add_edge("support_node", END)
builder.add_edge("sales_node", END)
builder.add_edge("general_node", END)

graph = builder.compile()
```

```python
graph.invoke({"message": "", "response": "", "department": ""})
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Soporte TÃ©cnico ---
{'message': 'Necesito soporte tÃ©cnico',
 'response': 'Te estamos transfiriendo a soporte tÃ©cnico.',
 'department': 'Soporte TÃ©cnico'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': 'Quiero comprar un producto',
 'response': 'Te conectamos con el equipo de ventas.',
 'department': 'Ventas'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Consultas Generales ---
{'message': 'Tengo una pregunta general',
 'response': 'Tu consulta serÃ¡ respondida a la brevedad.',
 'department': 'Consultas Generales'}
```

El estado reflejarÃ¡ tanto la respuesta del nodo como el departamento al que fue transferido el usuario.

## ğŸ§‘â€ğŸ« Â¿QuÃ© Hemos Aprendido?

- **Routers:** Son nodos que gestionan mÃºltiples bifurcaciones desde un solo punto.
- **CentralizaciÃ³n y Escalabilidad:** Los routers permiten mantener un grafo limpio y organizado, facilitando la expansiÃ³n.
- **Flujos DinÃ¡micos:** Los routers toman decisiones en tiempo real basadas en el estado o entrada del usuario.

---

## ğŸŒ Â¿QuÃ© es lo Siguiente?

En el prÃ³ximo tema, hablaremos de **Reducers**, que permiten consolidar datos y resultados de diferentes caminos dentro del grafo.  
Los reducers trabajan en conjunto con los routers, formando flujos completos y optimizados.
