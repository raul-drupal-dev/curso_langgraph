# ğŸ§© Tema 3: State Schema

## ğŸš€ Â¿QuÃ© es el State Schema?  

El **State Schema** en LangGraph define la estructura de datos que viaja a travÃ©s de un grafo durante su ejecuciÃ³n.  
Es como el â€œADNâ€ del flujo, que **transporta y actualiza informaciÃ³n** a medida que se avanza por diferentes nodos, piensa en el estado como una mochila ğŸ§³ que lleva datos entre los nodos, la cual vamos llenando o vaciando a medida que vamos necesitando.

### ğŸ§  Â¿Por quÃ© es importante?  
El State Schema permite:  
- **Controlar y validar los datos** que circulan por el grafo.  
- **Definir tipos de datos especÃ­ficos** (texto, listas, enteros, etc.) para evitar errores.  
- **Modificar y actualizar atributos** a lo largo del flujo.  

Imagina que estÃ¡s construyendo un asistente virtual:  
- El State podrÃ­a contener atributos como el nombre del usuario, historial de mensajes y preferencias.  
- A medida que la conversaciÃ³n avanza, los nodos modifican o consultan estos atributos.  

---

## âš™ï¸ Â¿CÃ³mo se Define el State Schema?  

Para definir un `State` personalizado, utilizamos `TypedDict`. Esto nos permite crear una plantilla de estado con atributos especÃ­ficos y sus respectivos tipos.  

### ğŸ“‹ Ejemplo: CreaciÃ³n de un State con Varios Atributos  
```python
from typing_extensions import TypedDict
from typing import Literal

class State(TypedDict):
    name: str
    age: int
    preferences: Literal["Videojuegos","ProgramaciÃ³n"]
``` 

---

### ğŸ§© ExplicaciÃ³n:  
- **`TypedDict`** crea una plantilla para el estado.  
- **`name` y `age`** son atributos que definen el nombre y edad de un usuario.  
- **`preferences`** es una lista que guarda intereses o preferencias. Usando `Literal` forzamos a que la aplicaciÃ³n solamente guarde esos terminos en concreto.  

Con esto, aseguramos que el estado tenga una estructura clara y solo acepte los tipos de datos definidos.  

---

## ğŸ”„ Â¿CÃ³mo Funciona el State en un Grafo?  

El `State` fluye de un nodo a otro, llevando consigo informaciÃ³n que puede **ser modificada, eliminada o ampliada**.  
Cada nodo puede:  
- **Leer atributos** del estado.  
- **Modificar datos existentes.**  
- **Agregar nuevos atributos** si es necesario.  

Esto nos permite construir flujos dinÃ¡micos y adaptativos, donde el grafo evoluciona segÃºn las interacciones del usuario o los cÃ¡lculos realizados.  

---

## ğŸ› ï¸ Ejemplo Completo con Nodos  

Vamos a construir un grafo que:  
1. Reciba el nombre y edad del usuario.  
2. Modifique el estado agregando una preferencia de acuerdo con la edad.  

---

### ğŸ“‹ Definiendo Nodos para Modificar el Estado  
```python
def user_input_node(state: State):
    print("--- Nodo 1: Recibir Usuario ---")
    state["name"] = "Raul"
    state["preferences"] = []
    return state

def recommendation_node(state: State):
    print("--- Nodo 2: RecomendaciÃ³n ---")
    if state["age"] < 18:
        state["preferences"].append("Videojuegos")
    else:
        state["preferences"].append("ProgramaciÃ³n")
    return state

```

- **Nodo `user_input_node`**: Toma el nombre, inicializa las preferencias y los aÃ±ade al estado.  
- **Nodo `recommendation_node`**: Agrega recomendaciones basadas en la edad del usuario.  

---

### ğŸ—ï¸ ConstrucciÃ³n del Grafo  
```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input_node)
builder.add_node("recommendation", recommendation_node)

builder.add_edge(START, "user_input")
builder.add_edge("user_input", "recommendation")
builder.add_edge("recommendation", END)

graph = builder.compile()

```

ExplicaciÃ³n de cada paso:  
1. **Creamos el grafo con `StateGraph`.**  
2. **AÃ±adimos los nodos.**  
3. **Definimos el flujo:**  
   - El grafo comienza en `START` y pasa por `user_input_node`.  
   - Luego se dirige a `recommendation_node` antes de finalizar (`END`).  

---

## ğŸ“ˆ VisualizaciÃ³n del Grafo
Para observar cÃ³mo se estructura nuestro grafo, generamos una visualizaciÃ³n:

```python
from IPython.display import Image, display

display(Image(graph.get_graph().draw_mermaid_png()))
```

![Grafo state schema](../assets/img/curso1/tema3/image.png)

---

## ğŸš€ Invocando el Grafo y Resultados  

### EjecuciÃ³n del Grafo  
```python
graph.invoke({"name": "", "age": 40})
```

---

### ğŸ“Š Resultados Esperados  
```python
--- Nodo 1: Recibir Usuario ---
--- Nodo 2: RecomendaciÃ³n ---
{'name': 'Raul', 'age': 40, 'preferences': ['ProgramaciÃ³n']}
```

- Si el usuario tiene menos de 18 aÃ±os, el grafo recomienda videojuegos.  
- Si tiene 18 o mÃ¡s, se recomienda programaciÃ³n.  

---

## ğŸ§‘â€ğŸ« Â¿QuÃ© Hemos Aprendido?  

- **State Schema:** Define la estructura de datos que viaja por el grafo.  
- **TypedDict:** Permite definir el esquema con tipos especÃ­ficos, asegurando que el estado tenga una estructura clara y validada.  
- **Nodos y Estado:** Los nodos pueden modificar y ampliar el estado, creando flujos dinÃ¡micos.  

---

## ğŸŒ Â¿QuÃ© es lo Siguiente?  

En el prÃ³ximo tema, profundizaremos en el uso de **Memoria en LangGraph**.  
Aprenderemos cÃ³mo usar `MemorySaver` para almacenar datos a lo largo de mÃºltiples invocaciones, creando flujos de trabajo que recuerdan informaciÃ³n pasada.  
