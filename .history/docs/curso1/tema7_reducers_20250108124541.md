# ğŸ”„ Tema 6: Reducers

## ğŸš€ Â¿QuÃ© es un Reducer en LangGraph?  

Los **reducers** en LangGraph permiten consolidar y procesar datos provenientes de diferentes nodos o caminos.  
Cuando un grafo sigue **flujos paralelos o mÃºltiples bifurcaciones**, los reducers **recogen, combinan o modifican** los resultados, facilitando una salida coherente y organizada.  

ğŸ‘‰ **Piensa en un reducer como un colector de datos** que une los resultados de distintas partes del grafo en un solo punto.  

---

### ğŸ§  Â¿Por quÃ© son Importantes los Reducers?  

- **ConsolidaciÃ³n de Datos:** ReÃºne informaciÃ³n de diferentes nodos y la almacena en el estado.  
- **Flujos Complejos:** Permite manejar y combinar respuestas de mÃºltiples caminos paralelos.  
- **Evitan Sobrescrituras No Deseadas:** Sin un reducer, cada actualizaciÃ³n sobrescribe el valor existente.  

---

## âš™ï¸ Â¿CÃ³mo Funciona un Reducer?  

Cuando un nodo devuelve datos parciales del estado, el reducer **decide cÃ³mo aplicar esos datos**:  
- **Sin Reducer:** El valor existente se **sobrescribe.**  
- **Con Reducer:** Los datos se **combinan o acumulan** siguiendo una lÃ³gica definida.  

ğŸ‘‰ **Ejemplo:** Si tienes una lista de mensajes, un reducer puede aÃ±adir nuevos mensajes al final, en lugar de borrar el historial anterior.  

---

## ğŸ” Ejemplo A: Sin Reducer (Sobrescritura Directa)  

En este caso, cada vez que un nodo devuelve un valor, sobrescribe el valor anterior:  

```python
from typing_extensions import TypedDict
from langchain_core.messages import AnyMessage

class State(TypedDict):
    messages: list[AnyMessage]  # Sin reducer (sobrescribe)
    response: str
    department: str
``` 

---

### ğŸ” ExplicaciÃ³n:  
- La clave `messages` no tiene un reducer asignado.  
- **Cada actualizaciÃ³n de mensajes reemplaza por completo la lista anterior.**  
- El Ãºltimo mensaje serÃ¡ el Ãºnico que quede en el estado.  

---

## ğŸ“‹ Ejemplo B: Con Reducer (AcumulaciÃ³n de Mensajes)  

Usamos `Annotated` y `add_messages` para acumular mensajes en lugar de sobrescribirlos:  
 
```python
from typing import Annotated
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]  # Con reducer (acumula)
    response: str
    department: str
``` 

- **`Annotated`** permite aÃ±adir metadatos a `messages` para definir un reducer.  
- **`add_messages`** acumula mensajes en el historial, evitando sobrescrituras.  
- Cada vez que un nodo aÃ±ade un mensaje, este se agrega al final de la lista.  

---

## ğŸ› ï¸ Ejemplo Completo: Comparando con y sin Reducer  

Vamos a construir un grafo de chatbot que:  
1. Recibe el mensaje del usuario.  
2. Redirige al nodo correspondiente (soporte, ventas, general).  
3. AÃ±ade respuestas al historial de mensajes usando un reducer.  

Veremos cÃ³mo cambia el resultado al usar un reducer para `messages`.  

```python
from langchain_core.messages import HumanMessage, AIMessage

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    state["messages"].append(HumanMessage(content="Hola, tengo una pregunta."))
    return state

def support_node(state: State):
    print("--- Nodo de Soporte TÃ©cnico ---")
    state["messages"].append(AIMessage(content="Te estamos transfiriendo a soporte."))
    state["response"] = "Soporte"
    return state

def route_request(state: State) -> str:
    return "support_node"
```  

---

## ğŸš€ Invocando el Grafo  

Probamos el grafo sin reducer y luego con `add_messages` para observar la diferencia.  

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("support_node", support_node)

builder.add_edge(START, "user_input")
builder.add_edge("user_input", "support_node")
builder.add_edge("support_node", END)

graph = builder.compile()
graph.invoke({"messages": [], "response": "", "department": ""})
``` 

---

### ğŸ“Š Resultado Esperado  
[resultado1]  
```python
# Sin reducer (sobrescribe)
{'messages': [AIMessage(content="Te estamos transfiriendo a soporte.")],
 'response': 'Soporte',
 'department': ''}
``` 

- **Sin Reducer:** Solo el Ãºltimo mensaje aparece en el estado.  
- **Con Reducer:** El historial acumula todos los mensajes y respuestas.  

---

## âœ¨ Â¿CÃ³mo Crear un Reducer Personalizado?  

Si necesitas una lÃ³gica especÃ­fica que `add_messages` no cubre, puedes crear tu propio reducer.  

A continuaciÃ³n, definimos un reducer personalizado que **cuenta cuÃ¡ntos mensajes se han procesado** y actualiza el estado con ese total:  

[codigo5]  
```python
``` 

---

## ğŸš€ InvocaciÃ³n con Reducer Personalizado  

Ejecutamos el grafo y verificamos cÃ³mo el estado se actualiza con el nÃºmero total de mensajes.  
[codigo6] 
```python
```  

---

### ğŸ“Š Resultado Esperado  
[resultado2]  
```python
``` 

El estado reflejarÃ¡ tanto el historial de mensajes como el conteo total.  

---

## ğŸ§‘â€ğŸ« Â¿QuÃ© Hemos Aprendido?  

- **Reducers:** Controlan cÃ³mo se actualiza el estado durante el flujo del grafo.  
- **add_messages:** Permite acumular mensajes, evitando sobrescrituras.  
- **Reducers Personalizados:** Proporcionan flexibilidad para definir cualquier lÃ³gica de actualizaciÃ³n.  

---

## ğŸŒ Â¿QuÃ© es lo Siguiente?  

En el prÃ³ximo tema, exploraremos **Tools (Herramientas)**, viendo cÃ³mo integrar funciones externas y APIs dentro del grafo para ampliar sus capacidades.  


https://langchain-ai.github.io/langgraph/concepts/low_level/?h=reducers#reducers
