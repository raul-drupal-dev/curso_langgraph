# üîÑ Tema 6: Reducers

## üöÄ ¬øQu√© es un Reducer en LangGraph?  

Los **reducers** en LangGraph permiten consolidar y procesar datos provenientes de diferentes nodos o caminos.  
Cuando un grafo sigue **flujos paralelos o m√∫ltiples bifurcaciones**, los reducers **recogen, combinan o modifican** los resultados, facilitando una salida coherente y organizada.  

üëâ **Piensa en un reducer como un colector de datos** que une los resultados de distintas partes del grafo en un solo punto.  

---

### üß† ¬øPor qu√© son Importantes los Reducers?  

- **Consolidaci√≥n de Datos:** Re√∫ne informaci√≥n de diferentes nodos y la almacena en el estado.  
- **Flujos Complejos:** Permite manejar y combinar respuestas de m√∫ltiples caminos paralelos.  
- **Evitan Sobrescrituras No Deseadas:** Sin un reducer, cada actualizaci√≥n sobrescribe el valor existente.  

---

## ‚öôÔ∏è ¬øC√≥mo se Define un Reducer?  

LangGraph proporciona reducers predefinidos como `add_messages`, que facilita la consolidaci√≥n de listas de mensajes en el estado.  
Esto es especialmente √∫til en flujos conversacionales donde el historial de mensajes **se acumula a lo largo del tiempo.**  

---

### üìã Ejemplo Pr√°ctico: Reducer con `add_messages`  

A continuaci√≥n, definiremos un `State` personalizado que incluye un historial de mensajes que se actualizar√° usando `add_messages`.  

```python
from typing import Annotated
from langgraph.graph import MessagesState
from langchain_core.messages import AnyMessage
from langgraph.graph.message import add_messages

# Define un estado con historial de mensajes usando add_messages
class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    response: str
    department: str
``` 

---

### üîç Explicaci√≥n del Ejemplo:  

- **`Annotated`**: Permite agregar metadatos al campo `messages` que especifica el uso del reducer `add_messages`.  
- **`add_messages`**: Es un reducer que **a√±ade nuevos mensajes al historial** sin sobrescribir los existentes.  
- **Estado Personalizado:** Adem√°s del historial, agregamos claves (`response`, `department`) que se actualizar√°n con el flujo del grafo.  

---  

## üõ†Ô∏è Ejemplo Completo con Reducers  

Vamos a modificar el chatbot de departamentos para **almacenar el historial de mensajes** de cada nodo.  
Cada vez que un nodo procese el mensaje del usuario, **se a√±adir√° al historial existente.**  

```python
from langchain_core.messages import HumanMessage, AIMessage

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    state["messages"].append(HumanMessage(content="Hola, necesito ayuda."))
    return state

def support_node(state: State):
    print("--- Nodo de Soporte T√©cnico ---")
    state["messages"].append(AIMessage(content="Te estamos transfiriendo a soporte t√©cnico."))
    state["department"] = "Soporte"
    return state

def route_request(state: State) -> str:
    return "support_node"
```  

---

### üîç Explicaci√≥n del Nuevo Flujo:  

- **Nodo de Entrada (user_input):** A√±ade el primer mensaje al historial.  
- **Router (route_request):** Determina el nodo de destino (soporte, ventas o general).  
- **Nodos de Departamento:** Cada nodo a√±ade una respuesta al historial mediante `add_messages`.  

---

## üöÄ Invocando el Grafo con Reducers  

Ejecutamos el grafo y observamos c√≥mo se acumulan los mensajes en el historial.  

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("support_node", support_node)

builder.add_edge(START, "user_input")
builder.add_edge("user_input", "support_node")
builder.add_edge("support_node", END)

graph = builder.compile()
graph.invoke({"messages": [], "added_key_1": "", "added_key_2": ""})
``` 

```python title="Resultado"
{'messages': [
    HumanMessage(content="Hola, necesito ayuda."), 
    AIMessage(content="Te estamos transfiriendo a soporte t√©cnico.")
  ], 
  'added_key_1': 'Soporte', 
  'added_key_2': ''
}

``` 

El historial de mensajes muestra el recorrido completo, consolidando tanto las entradas del usuario como las respuestas del chatbot.  

---

## ‚ú® Creaci√≥n de un Reducer Personalizado  

A veces, los reducers predefinidos no cubren todas las necesidades. LangGraph permite **crear reducers personalizados** para manipular el estado de maneras m√°s espec√≠ficas.  

---

### üìã Ejemplo: Reducer Personalizado para Contar Mensajes  

Definiremos un reducer que **cuenta cu√°ntos mensajes se han procesado** y actualiza el estado con el total acumulado.  
 
```python
def count_messages(existing, new):
    return existing + len(new)

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    total_messages: Annotated[int, count_messages]
``` 

---

### üîç Explicaci√≥n del Reducer Personalizado:  

- **`count_messages`**: Cada vez que se a√±ade un mensaje, incrementa un contador en el estado.  
- **Flexibilidad Total:** Permite definir cualquier l√≥gica de consolidaci√≥n seg√∫n los requisitos del flujo.  

---

## üöÄ Probamos el Reducer Personalizado  

Invocamos el grafo y verificamos c√≥mo el estado se actualiza con el n√∫mero total de mensajes.  
  
```python
graph.invoke({"messages": [], "total_messages": 0})
``` 

```python title="Resultado"
{'messages': [
    HumanMessage(content="Hola, necesito ayuda."), 
    AIMessage(content="Te estamos transfiriendo a soporte t√©cnico.")
  ], 
  'total_messages': 2
}
``` 

El estado reflejar√° tanto el historial de mensajes como el total acumulado.  

---

https://langchain-ai.github.io/langgraph/concepts/low_level/?h=reducers#reducers
