# ğŸ§© Tema 3: State Schema y Memoria  

## ğŸš€ Â¿QuÃ© es el State Schema y la Memoria en LangGraph?  

El **State Schema** es el corazÃ³n de LangGraph, ya que define y gestiona el estado del grafo durante su ejecuciÃ³n.  
El **estado** es la informaciÃ³n que **se transfiere, modifica y actualiza** a medida que el flujo avanza por diferentes nodos.  

Piensa en el estado como una mochila ğŸ§³ que lleva datos entre los nodos. En cada nodo, puedes:  
- **AÃ±adir** nuevos datos.  
- **Modificar** valores existentes.  
- **Eliminar** informaciÃ³n que ya no necesitas.  

### ğŸ§  Â¿Y la Memoria?  
La memoria es la capacidad que tiene el grafo para **recordar informaciÃ³n** a lo largo de mÃºltiples invocaciones. Es especialmente Ãºtil cuando creamos chatbots o flujos conversacionales donde el contexto es crucial.  

- **Sin memoria:** Cada vez que invocamos el grafo, comienza desde cero.  
- **Con memoria:** El grafo guarda un historial de mensajes o datos, permitiendo respuestas basadas en todo el contexto anterior.  

**Â¿Por quÃ© es importante?**  
- **Persistencia de datos.**  
- **Toma de decisiones basadas en el contexto actual.**  
- **Mayor precisiÃ³n en interacciones prolongadas.**  

---

## âš™ï¸ Â¿CÃ³mo Funciona el State?  

Para entender cÃ³mo se define el estado en LangGraph, crearemos un `State` personalizado.  
Este enfoque facilita la comprensiÃ³n antes de utilizar estructuras predefinidas como `MessagesState`.  

### ğŸ“‹ CreaciÃ³n de un State Propio  
```python
from typing_extensions import TypedDict

class State(TypedDict):
    graph_state: str
```

- **ExplicaciÃ³n:**  
  - `TypedDict` nos permite definir un diccionario con tipos estrictos, lo que asegura que el estado tenga una estructura clara y esperada.  
  - El `graph_state` es un campo donde almacenaremos mensajes o datos que pasarÃ¡n de un nodo a otro.  

Si prefieres simplificar, puedes utilizar el estado predefinido `MessagesState` de LangGraph, diseÃ±ado especÃ­ficamente para flujos conversacionales.  
ğŸ‘‰ [DocumentaciÃ³n de MessagesState](https://python.langchain.com/docs/modules/langgraph#messagesstate)  

---

## ğŸ§© Nodos que Utilizan el Estado  

A continuaciÃ³n, crearemos dos nodos que utilizan el estado:  
1. **Nodo de entrada del usuario:** Agrega el mensaje del usuario al estado.  
2. **Nodo de respuesta de IA:** El modelo de OpenAI (`gpt-4o-mini`) genera una respuesta basada en el historial.  

```python  
```

- **`user_input_node:`** Toma el mensaje del usuario y lo guarda en el estado.  
- **`ai_response_node:`** Usa el estado actual (historial) para generar una respuesta de IA.  

---

## ğŸ§  Memoria: Â¿CÃ³mo Funciona?  

LangGraph ofrece varios tipos de memoria:  

1. **Memoria de Estado (State Memory):**  
   - El estado se transfiere de nodo a nodo, reteniendo informaciÃ³n solo durante una invocaciÃ³n.  
   
2. **Memoria de Corto Alcance (MemorySaver):**  
   - Guarda datos durante mÃºltiples invocaciones, pero **no persiste despuÃ©s de cerrar el programa.**  
   - Almacena la informaciÃ³n en memoria volÃ¡til (RAM).  
   - Ideal para flujos temporales que necesitan recordar el contexto durante la sesiÃ³n actual.  
   ğŸ‘‰ [DocumentaciÃ³n de MemorySaver](https://python.langchain.com/docs/modules/langgraph#memorysaver)  

3. **Memoria Persistente (Postgres u otros):**  
   - Permite almacenar el historial en bases de datos externas (ej: PostgreSQL).  
   - **Se verÃ¡ en temas mÃ¡s avanzados.**  

4. **Memoria Transversal (Cross-Session Memory):**  
   - Conserva datos a lo largo de mÃºltiples sesiones y usuarios.  
   - **Se estudiarÃ¡ en profundidad en futuros mÃ³dulos.**  

---

## ğŸ—ï¸ AÃ±adiendo Memoria al Grafo  

Ahora implementaremos el `MemorySaver` para agregar memoria de corto alcance a nuestro grafo.  

### ğŸ“‹ Grafo sin Memoria  
```python  
```
[codigo3]  

### ğŸ“‹ Grafo con Memoria  
```python  
```
[codigo4]  

---

## ğŸ“ˆ VisualizaciÃ³n del Grafo  

Para observar cÃ³mo se estructura nuestro grafo, generamos una visualizaciÃ³n:  
```python  
```
[codigo5]  

---

## ğŸš€ Invocando el Grafo y Comparando Resultados  

### ğŸ“‹ Sin Memoria  
```python  
```
[codigo6]  
```python  
```
[resultado1]  

---

### ğŸ“‹ Con Memoria  
```python  
```
[codigo7]  
[resultado2]  

---

## ğŸ§‘â€ğŸ« Â¿QuÃ© Hemos Aprendido?  

- **State Schema:** Es la estructura que define quÃ© datos se transportan y modifican durante el flujo del grafo.  
- **Memoria de Estado (State):** Solo persiste durante la ejecuciÃ³n de una invocaciÃ³n.  
- **MemorySaver:** Proporciona memoria de corto alcance para retener datos durante mÃºltiples invocaciones.  
- **Diferencias Clave:** Sin memoria, cada invocaciÃ³n es independiente. Con memoria, el grafo recuerda datos anteriores.  

---

## ğŸŒ Â¿QuÃ© es lo Siguiente?  

En el siguiente tema exploraremos **Chains y Flujos de Trabajo**, donde aprenderemos a encadenar nodos y construir pipelines complejos.  
TambiÃ©n abordaremos el tema de **Tools (Herramientas)**, pero lo veremos **despuÃ©s de Chains**, ya que comprender primero el flujo de trabajo harÃ¡ que la integraciÃ³n de herramientas sea mÃ¡s sencilla y prÃ¡ctica.  
