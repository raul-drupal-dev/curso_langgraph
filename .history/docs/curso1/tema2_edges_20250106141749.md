# ðŸŽ¯ Tema 2: Edges (Conexiones)

## ðŸ§© Â¿QuÃ© son los Edges?  
Los **edges** son las conexiones entre nodos que dirigen el flujo de datos de un nodo a otro. Estas conexiones pueden ser:  

- **Directas:** Conectan un nodo con el siguiente sin condiciones.  
- **Condicionales:** Deciden dinÃ¡micamente quÃ© nodo visitar a continuaciÃ³n basÃ¡ndose en una funciÃ³n lÃ³gica.  

En este ejemplo, utilizaremos un flujo de decisiÃ³n aleatorio para mostrar cÃ³mo se pueden agregar edges y bifurcaciones.  

---

## ðŸ› ï¸ Ejemplo PrÃ¡ctico: Construyendo un Grafo con Edges  

Usando el cÃ³digo usado anteriormente con los nodos, mostramos el cÃ³digo de ejemplo que ilustra cÃ³mo agregar edges entre nodos:  

```python
def node_1(state):
    print("---Node 1---")
    return {"graph_state": state['graph_state'] + " Me gusta"}

def node_2(state):
    print("---Node 2---")
    return {"graph_state": state['graph_state'] + " programar!"}

def node_3(state):
    print("---Node 3---")
    return {"graph_state": state['graph_state'] + " salir en bici!"}
```

---

### ðŸ” ExplicaciÃ³n Paso a Paso  

#### ðŸ“Œ DefiniciÃ³n de Nodos  

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)
```

- **`node_1`**: AÃ±ade al estado `"Me gusta"`.  
- **`node_2`**: AÃ±ade al estado `"programar!"`.  
- **`node_3`**: AÃ±ade al estado `"salir en bici!"`.  

En este caso, `node_1` actÃºa como punto de partida para las decisiones que se tomarÃ¡n posteriormente.  

---

#### ðŸ”„ DecisiÃ³n con Condiciones  

```python
import random
from typing import Literal

def decide_hooby(state) -> Literal["node_2", "node_3"]:
    if random.random() < 0.5:
        return "node_2"
    return "node_3"
``` 


La funciÃ³n `decide_hooby` decide, de forma aleatoria, si el flujo debe continuar hacia `node_2` o `node_3`.  

- **50%** de probabilidad de ir a `node_2` (programar).  
- **50%** de probabilidad de ir a `node_3` (salir en bici).  

Este edge condicional permite que el grafo tenga mÃºltiples rutas de ejecuciÃ³n.  

---

#### ðŸ—ï¸ ConstrucciÃ³n del Grafo  

```python
builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_hooby)
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)

graph = builder.compile()
```  

- **`add_edge`**: Conecta directamente `START` con `node_1`.  
- **`add_conditional_edges`**: Desde `node_1`, el flujo se bifurca condicionalmente hacia `node_2` o `node_3`.  
- **`add_edge` (Final)**: Ambos nodos (`node_2` y `node_3`) terminan en el nodo final `END`.  

---

### ðŸ“ˆ Visualizando el Grafo  

Una vez construido, podemos visualizar el grafo:  

```python
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
``` 

---

## âš™ï¸ Invocando el Grafo  

Para ejecutar el grafo y ver su comportamiento, utilizamos:  

```python
graph.invoke({"graph_state" : "Hola, me llamo Raul."})
```
```phyton title="Resultado 1"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. Me gusta programar!'}
```
```phyton title="Resultado 2"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. Me gusta salir en bici!'}
```


## ðŸ§© Â¿QuÃ© Hemos Aprendido?  

- **Edges (Conexiones):** Son las rutas que conectan nodos en el grafo, permitiendo el flujo de informaciÃ³n de un nodo a otro.  
- **Edges Condicionales:** Permiten bifurcaciones en el flujo, tomando decisiones dinÃ¡micas que afectan el camino que sigue el grafo.  
- **Flujo de Trabajo DinÃ¡mico:** Al conectar nodos de forma condicional, podemos crear grafos mÃ¡s complejos y adaptativos, generando diferentes resultados segÃºn la lÃ³gica aplicada.  
- **ConstrucciÃ³n de Grafos:** Hemos aprendido a agregar nodos, edges y compilar el grafo usando `StateGraph` y `add_edge`.  

---

## ðŸŒ Â¿QuÃ© es lo Siguiente?  

En el siguiente tema, profundizaremos en **State Schema y Memoria**. Aprenderemos:  
- **CÃ³mo almacenar y mantener el estado** a lo largo del flujo del grafo.  
- **Estrategias para preservar memoria** en LangGraph.  
- **Esquemas de estado personalizados** para que el grafo retenga y modifique informaciÃ³n de manera continua.  

Â¡Nos vemos en el prÃ³ximo tema! ðŸš€  


