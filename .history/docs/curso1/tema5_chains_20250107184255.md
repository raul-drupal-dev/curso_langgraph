# ğŸ”— Tema 5: Chains â€“ ConstrucciÃ³n de Flujos de Trabajo  

## ğŸš€ Â¿QuÃ© son las Chains en LangGraph?  

Las **Chains (cadenas)** son uno de los componentes mÃ¡s esenciales dentro de LangGraph.  
Permiten **encadenar mÃºltiples nodos y funciones** para crear flujos de trabajo complejos y estructurados.  

Piensa en las chains como una **lÃ­nea de montaje**, donde cada nodo realiza una tarea especÃ­fica y pasa el resultado al siguiente.  

Esto permite dividir procesos en **pasos mÃ¡s manejables y reutilizables**. 

Sin embargo, no todos los flujos siguen un camino lineal. A veces, es necesario **bifurcar el flujo** en funciÃ³n de ciertas condiciones.  


---

### ğŸ§  Â¿Por quÃ© usar Chains?  

- **Modularidad:** Dividir grandes procesos en nodos pequeÃ±os facilita el mantenimiento y la depuraciÃ³n.  
- **ReutilizaciÃ³n:** Las chains pueden componerse de nodos reutilizables en diferentes flujos.  
- **Escalabilidad:** Permiten construir flujos extensibles que pueden crecer fÃ¡cilmente aÃ±adiendo mÃ¡s nodos.  

---

## âš™ï¸ Â¿CÃ³mo se Define una Chain?  

Crear una chain en LangGraph implica:  
1. **Definir nodos individuales.**  
2. **Encadenar esos nodos en una secuencia lÃ³gica.**  
3. **Permitir bifurcaciones condicionales si es necesario.**  

AdemÃ¡s de encadenar nodos de forma secuencial, podemos agregar **bifurcaciones condicionales** para que el grafo tome diferentes rutas segÃºn el estado actual.  

---

### ğŸ“‹ Ejemplo PrÃ¡ctico: CreaciÃ³n de una Chain  

Vamos a construir un flujo simple que:  
1. Reciba el nombre del usuario.  
2. Salude al usuario.  
3. **Sugiera una actividad diferente segÃºn la hora del dÃ­a (maÃ±ana o tarde).**  
 
```python
from typing_extensions import TypedDict

class State(TypedDict):
    message: str
    response: str

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    print(state["message"])
    return state

def route_request(state: State) -> str:
    message = state["message"].lower()
    if "soporte" in message or "problema" in message:
        return "support_node"
    elif "comprar" in message or "precio" in message:
        return "sales_node"
    else:
        return "general_node"

def support_node(state: State):
    print("--- Nodo de Soporte TÃ©cnico ---")
    state["response"] = "Te estamos transfiriendo a soporte tÃ©cnico."
    return state

def sales_node(state: State):
    print("--- Nodo de Ventas ---")
    state["response"] = "Te conectamos con el equipo de ventas."
    return state

def general_node(state: State):
    print("--- Nodo de Consultas Generales ---")
    state["response"] = "Tu consulta serÃ¡ respondida a la brevedad."
    return state
``` 

- **Nodo 1 (user_input):** Recoge el nombre del usuario.  
- **Nodo 2 (greet_user):** Genera un saludo personalizado.  
- **Nodo 3 y Nodo 4 (suggest_morning/suggest_afternoon):**  
    - Si es por la maÃ±ana, el flujo sugiere tomar un cafÃ©.  
    - Si es por la tarde, se recomienda dar un paseo.  
- **FunciÃ³n `decide_path`:** EvalÃºa la hora actual para bifurcar el flujo hacia el nodo adecuado.   

---

## ğŸ—ï¸ ConstrucciÃ³n del Grafo con Chains  

Encadenamos los nodos en secuencia para formar la chain completa.  
```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("greet_user", greet_user)
builder.add_node("suggest_morning", suggest_morning)
builder.add_node("suggest_afternoon", suggest_afternoon)

builder.add_edge(START, "user_input")
builder.add_edge("user_input", "greet_user")
builder.add_conditional_edges("greet_user", decide_path)
builder.add_edge("suggest_morning", END)
builder.add_edge("suggest_afternoon", END)

graph = builder.compile()
```

---

## ğŸ“ˆ VisualizaciÃ³n del Grafo  

Para observar cÃ³mo se estructura nuestro grafo, generamos una visualizaciÃ³n:  
```python  
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
```  

![grafo chain](../assets/img/curso1/tema5/image.png)

---

### ğŸš€ Invocando el Grafo  

Ahora ejecutamos el grafo con una entrada simple.  
```python
graph.invoke({"name": "", "message": ""})
``` 

```python title="Resultado 1"
--- Nodo 1: Entrada del Usuario ---
--- Nodo 2: Saludo ---
--- Nodo 3: MaÃ±ana ---
{'name': 'Raul', 'message': 'Hola Raul, Â¡bienvenido de nuevo! Te recomiendo empezar el dÃ­a con un cafÃ© â˜•ï¸'}
```
```python title="Resultado 2"
--- Nodo 1: Entrada del Usuario ---
--- Nodo 2: Saludo ---
--- Nodo 4: Tarde ---
{'name': 'Raul', 'message': 'Hola Raul, Â¡bienvenido de nuevo! Â¿QuÃ© tal salir a dar un paseo por la tarde? ğŸš¶â€â™‚ï¸'}
```


El grafo procesa cada nodo secuencialmente, generando una respuesta estructurada para el usuario.  

---

## ğŸ§‘â€ğŸ« Â¿QuÃ© Hemos Aprendido?  

- **Chains:** Permiten conectar nodos en secuencia, formando flujos de trabajo escalables y reutilizables.  
- **Modularidad:** Los nodos pueden realizar tareas pequeÃ±as que, al combinarse, crean flujos mÃ¡s complejos.  
- **Chains Condicionales:** Permiten bifurcar el flujo en funciÃ³n de valores dinÃ¡micos (como la hora o entradas del usuario).  
- **Encadenamiento Secuencial y DinÃ¡mico:** Los flujos no siempre son lineales, y LangGraph permite construir grafos que se adaptan a diferentes situaciones.  


---

## ğŸŒ Â¿QuÃ© es lo Siguiente?  

En el siguiente tema, exploraremos el uso de **Tools (Herramientas)**, donde aprenderemos cÃ³mo integrar funciones externas en un grafo para ampliar sus capacidades.  
