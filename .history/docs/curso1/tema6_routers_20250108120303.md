# üö¶ Tema 6: Routers ‚Äì Dirigiendo el Flujo del Grafo

## üöÄ ¬øQu√© es un Router en LangGraph?

Los **routers** en LangGraph son nodos especiales que permiten **redirigir el flujo hacia diferentes caminos** en funci√≥n de condiciones din√°micas.  
A diferencia de los **edges condicionales**, los routers **centralizan y gestionan m√∫ltiples bifurcaciones** desde un solo punto, haciendo que los grafos sean m√°s **modulares, limpios y escalables.**

---

### üß† ¬øPor qu√© usar Routers en lugar de Condicionales?

- **Centralizaci√≥n:** Un solo nodo puede gestionar m√∫ltiples caminos, evitando bifurcaciones dispersas.
- **Escalabilidad:** A medida que crecen los caminos posibles, los routers permiten expandir el grafo sin a√±adir complejidad.
- **Reutilizaci√≥n:** Un mismo router puede ser usado en **diferentes partes del grafo.**
- **Legibilidad:** Mantiene el grafo **organizado y f√°cil de seguir.**

üëâ **Piensa en el router como un sem√°foro** üö¶ que dirige el tr√°fico hacia diferentes carriles en funci√≥n de las se√±ales recibidas.

---

## ‚öôÔ∏è ¬øC√≥mo Funciona un Router?

Un router funciona tomando una **decisi√≥n basada en el estado del grafo** o en **par√°metros espec√≠ficos de entrada.**  
Define m√∫ltiples caminos posibles y selecciona uno, enviando el flujo hacia el nodo correspondiente.

---

## üìã Ejemplo Pr√°ctico: Chatbot con Router de Departamentos

Vamos a crear un chatbot que redirige al usuario a diferentes departamentos seg√∫n el tipo de pregunta:

1. **Soporte T√©cnico:** Para resolver problemas t√©cnicos.
2. **Ventas:** Para consultas de productos o servicios.
3. **Consultas Generales:** Para cualquier otra pregunta.

El router analizar√° el mensaje del usuario y lo dirigir√° al nodo adecuado.

```python
from typing_extensions import TypedDict

class State(TypedDict):
    message: str
    response: str

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    print(state["message"])
    return state

def route_request(state: State) -> str:
    message = state["message"].lower()
    if "soporte" in message or "problema" in message:
        return "support_node"
    elif "comprar" in message or "precio" in message:
        return "sales_node"
    else:
        return "general_node"

def support_node(state: State):
    print("--- Nodo de Soporte T√©cnico ---")
    state["response"] = "Te estamos transfiriendo a soporte t√©cnico."
    return state

def sales_node(state: State):
    print("--- Nodo de Ventas ---")
    state["response"] = "Te conectamos con el equipo de ventas."
    return state

def general_node(state: State):
    print("--- Nodo de Consultas Generales ---")
    state["response"] = "Tu consulta ser√° respondida a la brevedad."
    return state
```

---

### üîç Explicaci√≥n del Ejemplo:

- **Nodo 1 (user_input):** Recibe el mensaje del usuario.
- **Router (route_request):** Eval√∫a el mensaje y redirige al nodo correspondiente: `support_node`, `sales_node` o `general_node`.
- **Nodos de Respuesta:** Cada nodo proporciona una respuesta basada en el departamento al que se redirigi√≥ al usuario.

---

## üèóÔ∏è Construcci√≥n del Grafo con Router

Agregamos el router y conectamos cada nodo de respuesta al flujo.

```python
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("support_node", support_node)
builder.add_node("sales_node", sales_node)
builder.add_node("general_node", general_node)

builder.add_edge(START, "user_input")
builder.add_conditional_edges("user_input", route_request)
builder.add_edge("support_node", END)
builder.add_edge("sales_node", END)
builder.add_edge("general_node", END)

graph = builder.compile()
```

---

## üìà Visualizaci√≥n del Grafo

Para observar c√≥mo se estructura nuestro grafo, generamos una visualizaci√≥n:

```python
from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
```

![grafo routers](../assets/img/curso1/tema6/image.png)

---

## üöÄ Invocando el Grafo

Probamos el grafo con diferentes entradas para ver c√≥mo el router dirige el flujo.

```python
graph.invoke({"message": "", "response": ""})
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': 'Quiero comprar un producto', 'response': 'Te conectamos con el equipo de ventas.'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': 'Tengo un problema con mi cuenta', 'response': 'Te estamos transfiriendo a soporte t√©cnico.'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo de Ventas ---
{'message': '¬øCu√°l es el horario de atenci√≥n?', 'response': 'Tu consulta ser√° respondida a la brevedad.'}
```

Dependiendo del contenido del mensaje del usuario, el flujo tomar√° caminos distintos, demostrando el poder y flexibilidad de los routers.

---

## üõ†Ô∏è Usando "Command" para Modificar el Estado Durante el Enrutamiento

Adem√°s de redirigir el flujo del grafo, LangGraph permite **modificar el estado directamente desde el router** usando **Command**.  
Esto es √∫til cuando, adem√°s de dirigir al usuario a un nodo espec√≠fico, queremos **actualizar atributos del estado** sin necesidad de crear nodos adicionales.

---

### üöÄ ¬øQu√© es un Command en LangGraph?

Un **command** es una instrucci√≥n que permite realizar dos acciones simult√°neas:

1. **Enrutar el flujo del grafo hacia un nodo espec√≠fico.**
2. **Actualizar o modificar atributos del estado.**

---

### üß© ¬øPor Qu√© es √ötil?

- **Optimizaci√≥n:** Evita la necesidad de crear nodos adicionales solo para actualizar el estado.
- **Simplicidad:** Mantiene el flujo del grafo m√°s limpio y con menos nodos intermedios.
- **Eficiencia:** Reduce el n√∫mero de pasos y permite que el grafo sea m√°s din√°mico y reactivo.

---

### üìã Ejemplo Pr√°ctico con Command

Modificaremos nuestro chatbot para que, adem√°s de redirigir al usuario a un departamento, **actualice el estado** con un mensaje indicando a qu√© secci√≥n fue transferido.

```python hl_lines="2 14 17 19 21"
from typing_extensions import TypedDict, Literal
from langgraph.types import Command

class State(TypedDict):
    message: str
    response: str
    department: str

def user_input(state: State):
    print("--- Nodo 1: Entrada del Usuario ---")
    #state["message"] = "Necesito soporte t√©cnico"
    return state

def route_request(state: State) -> Command[Literal["support_node", "sales_node","general_node"]]:
    message = state["message"].lower()
    print("--- Nodo 2: Ruta de la Solicitud ---")
    if "soporte" in message:
        return Command(goto="support_node", update={"department": "Soporte T√©cnico"})
    elif "comprar" in message:
        return Command(goto="sales_node", update={"department": "Ventas"})
    else:
        return Command(goto="general_node", update={"department": "Consultas Generales"})

def support_node(state: State):
    print("--- Nodo de Soporte T√©cnico ---")
    print(state["department"])
    state["response"] = "Te estamos transfiriendo a soporte t√©cnico."
    return state

def sales_node(state: State):
    print("--- Nodo de Ventas ---")
    print(state["department"])
    state["response"] = "Te conectamos con el equipo de ventas."
    return state

def general_node(state: State):
    print("--- Nodo de Consultas Generales ---")
    print(state["department"])
    state["response"] = "Tu consulta ser√° respondida a la brevedad."
    return state
```

---

### üîç Explicaci√≥n del Ejemplo

- **Router con Command:** Ahora, el router no solo dirige el flujo sino que tambi√©n **actualiza el estado con el nombre del departamento** seleccionado.
- **Actualizaci√≥n Directa del Estado:** Esto nos permite **guardar un registro** de a qu√© nodo fue transferido el usuario, lo que puede ser √∫til para an√°lisis o futuros pasos en el flujo.

---

## üöÄ Invocando el Grafo

Probamos el grafo para observar c√≥mo se actualiza el estado durante el enrutamiento.

```python hl_lines="5 11 12"
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("user_input", user_input)
builder.add_node("route_request", route_request)
builder.add_node("support_node", support_node)
builder.add_node("sales_node", sales_node)
builder.add_node("general_node", general_node)

builder.add_edge(START, "user_input")
builder.add_edge("user_input","route_request")
# NOTE: No hay edges entre route_request y el resto de nodos!
builder.add_edge("support_node", END)
builder.add_edge("sales_node", END)
builder.add_edge("general_node", END)

graph = builder.compile()

from IPython.display import Image, display
display(Image(graph.get_graph().draw_mermaid_png()))
```

![grafo Command](../assets/img/curso1/tema6/image2.png)

```python
graph.invoke({"message": "", "response": "", "department": ""})
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo 2: Ruta de la Solicitud ---
--- Nodo de Soporte T√©cnico ---
{'message': 'Necesito soporte t√©cnico',
 'response': 'Te estamos transfiriendo a soporte t√©cnico.',
 'department': 'Soporte T√©cnico'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo 2: Ruta de la Solicitud ---
--- Nodo de Ventas ---
{'message': 'Quiero comprar un producto',
 'response': 'Te conectamos con el equipo de ventas.',
 'department': 'Ventas'}
```

```python title="Resultado"
--- Nodo 1: Entrada del Usuario ---
--- Nodo 2: Ruta de la Solicitud ---
--- Nodo de Consultas Generales ---
{'message': 'Tengo una pregunta general',
 'response': 'Tu consulta ser√° respondida a la brevedad.',
 'department': 'Consultas Generales'}
```

El estado reflejar√° tanto la respuesta del nodo como el departamento al que fue transferido el usuario.

---

## üîé Recursos:

- :simple-googlecolab: Ver notebook en [Google Colab](https://colab.research.google.com/drive/1jIalUKl-IZVg0BJ9eEA3CirFGDgQ56Hj?usp=sharing)
- :books: Definici√≥n [Command](https://langchain-ai.github.io/langgraph/concepts/low_level/#command)
- :books: How-to-guide [Command](https://langchain-ai.github.io/langgraph/how-tos/command/)


---

## üßë‚Äçüè´ ¬øQu√© Hemos Aprendido?

- **Routers:** Son nodos que gestionan m√∫ltiples bifurcaciones desde un solo punto.
- **Centralizaci√≥n y Escalabilidad:** Los routers permiten mantener un grafo limpio y organizado, facilitando la expansi√≥n.
- **Flujos Din√°micos:** Los routers toman decisiones en tiempo real basadas en el estado o entrada del usuario.

---

## üåê ¬øQu√© es lo Siguiente?

En el pr√≥ximo tema, hablaremos de **Reducers**, que permiten consolidar datos y resultados de diferentes caminos dentro del grafo.  
Los reducers trabajan en conjunto con los routers, formando flujos completos y optimizados.
