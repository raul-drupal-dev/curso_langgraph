# ðŸ§© Tema 1: Nodos en LangGraph

## Â¿QuÃ© es un Nodo?  
En LangGraph, los **nodos** representan las operaciones fundamentales que se realizan en un flujo de trabajo. Cada nodo se encarga de procesar datos o estados, y a partir de esto, devolver un nuevo estado o resultado.  
Piensa en los nodos como **piezas individuales de una mÃ¡quina** que trabajan juntas para completar una tarea compleja.  

Los nodos estÃ¡n conectados mediante **aristas (edges)** que permiten el flujo de informaciÃ³n entre ellos, formando un grafo que ejecuta operaciones de manera secuencial o condicional.  

---

## ðŸ› ï¸ Â¿CÃ³mo Funciona un Nodo?  
- Un nodo es una **funciÃ³n** que toma un estado de entrada y devuelve un nuevo estado.  
- Los nodos pueden representar tareas simples (como sumar nÃºmeros) o procesos mÃ¡s complejos (como ejecutar un modelo de IA).  
- Cada nodo tiene una conexiÃ³n hacia otros nodos, permitiendo que el flujo continÃºe segÃºn la lÃ³gica definida.  

---

## ðŸš€ Ejemplo: Construyendo un Grafo con Nodos  

Para entender mejor cÃ³mo funcionan los nodos, vamos a construir un grafo simple utilizando **LangGraph**.  

El objetivo serÃ¡ simular un grafo que cambia de estado y elige diferentes caminos en funciÃ³n de decisiones aleatorias.  

---

### 1. InstalaciÃ³n de LangGraph  
Primero, asegurÃ©monos de tener instalada la librerÃ­a LangGraph.  
```phyton
%pip install --quiet -U langgraph
``` 

---

### 2. Definiendo el Estado del Grafo  
El estado del grafo es una estructura que guarda informaciÃ³n sobre el progreso y los datos en cada paso.  
AquÃ­ definimos una clase `State` que representa el estado del grafo con una variable `graph_state` de tipo texto.  
```phyton
from typing_extensions import TypedDict

class State(TypedDict):
    graph_state: str
``` 

---

### 3. Creando los Nodos  

Ahora crearemos tres nodos simples:  
1. **Nodo 1**: Modifica el estado inicial agregando "Me gusta.  
2. **Nodo 2**: AÃ±ade "programar!" al estado.  
3. **Nodo 3**: AÃ±ade "salir en bici!" al estado.  

Cada nodo es una funciÃ³n que recibe el estado actual (`state`) y devuelve un nuevo estado modificado.  
```phyton
def node_1(state):
    print("---Node 1---")
    return {"graph_state": state['graph_state'] + " Me gusta"}

def node_2(state):
    print("---Node 2---")
    return {"graph_state": state['graph_state'] + " programar!"}

def node_3(state):
    print("---Node 3---")
    return {"graph_state": state['graph_state'] + " salir en bici!"}
``` 

---

### 4. Agregando LÃ³gica de DecisiÃ³n  

AquÃ­ agregamos una funciÃ³n `decide_hooby` que **decide aleatoriamente** si el flujo continÃºa hacia el **Nodo 2 (programar)** o el **Nodo 3 (salir en bici)**.  
Esto simula una bifurcaciÃ³n en el camino que dependerÃ¡ del resultado de una probabilidad del 50%.  
```phyton
import random
from typing import Literal

def decide_hooby(state) -> Literal["node_2", "node_3"]:
    if random.random() < 0.5:
        return "node_2"
    return "node_3"

```  

---

### 5. ConstrucciÃ³n del Grafo  

En este paso, construimos el grafo utilizando `StateGraph`.   

```phyton
from IPython.display import Image, display
from langgraph.graph import StateGraph, START, END

builder = StateGraph(State)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)

builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_hooby)
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)

graph = builder.compile()
```   
Vamos a explicar lÃ­nea por lÃ­nea: 

1. **`StateGraph(State)`**:  
    - Creamos una instancia de `StateGraph` y le pasamos el estado que definimos antes (`State`).  
    - **Â¿Por quÃ© lo hacemos?**: LangGraph necesita saber quÃ© tipo de estado manejarÃ¡ el grafo.   

2. **`builder.add_node("node_1", node_1)`**:  
    - AÃ±adimos el **Nodo 1** al grafo.  
    - El primer parÃ¡metro `"node_1"` es el identificador del nodo, y el segundo (`node_1`) es la funciÃ³n que ejecutarÃ¡.  

3. **`builder.add_node("node_2", node_2)`**:  
    - Agregamos el **Nodo 2**. Funciona de la misma forma que el Nodo 1.  

4. **`builder.add_node("node_3", node_3)`**:  
    - Agregamos el **Nodo 3** al grafo.  

5. **`builder.add_edge(START, "node_1")`**:  
    - Conectamos el punto de inicio (`START`) con el **Nodo 1**.  
    - Esto significa que cuando el grafo comience, lo harÃ¡ en el Nodo 1.  

6. **`builder.add_conditional_edges("node_1", decide_mood)`**:  
    - Desde el **Nodo 1**, agregamos una bifurcaciÃ³n condicional que ejecutarÃ¡ la funciÃ³n `decide_mood`.  
    - Dependiendo del resultado, el flujo se dirigirÃ¡ hacia el **Nodo 2 o 3**.  

7. **`builder.add_edge("node_2", END)`**:  
    - Si el flujo llega al Nodo 2, este finalizarÃ¡ (`END`).  

8. **`builder.add_edge("node_3", END)`**:  
    - De igual forma, si pasa por el Nodo 3, tambiÃ©n finalizarÃ¡.  

9. **`Finalmente, compilamos el grafo`**:  
    - **`graph = builder.compile()`**: Ensambla el grafo con todos los nodos y conexiones. 

---

### 6. VisualizaciÃ³n del Grafo  

Para visualizar el grafo, usamos la funciÃ³n `draw_mermaid_png()` que genera un diagrama del grafo.  
Esto nos permite ver grÃ¡ficamente cÃ³mo estÃ¡n conectados los nodos. 

```phyton
display(Image(graph.get_graph().draw_mermaid_png())) 
```  

![Grafica Nodos](../assets/img/curso1/tema1/image.png)

---

### 7. VisualizaciÃ³n del Grafo  

Ahora, vamos a ejecutar nuestro grafo, para ver que obtenemos.

```py
graph.invoke({"graph_state" : "Hola, me llamo Raul."})
```
```phyton title="Resultado"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. I am sad!'}
```

---

## ðŸ§© Â¿QuÃ© Hemos Aprendido?  
- **Nodos**: Son funciones que procesan datos y modifican el estado de un grafo.  
- **Decisiones Condicionales**: Podemos agregar lÃ³gica de bifurcaciÃ³n para que el flujo tome diferentes caminos.  
- **StateGraph**: Es la base sobre la que construimos el grafo, aÃ±adiendo nodos y conexiones.  
- **VisualizaciÃ³n**: LangGraph permite visualizar grÃ¡ficamente el flujo de trabajo.  

---

## ðŸŒ Siguientes Pasos  
En el siguiente tema aprenderemos sobre **Edges (Conexiones)**, que permiten conectar nodos y controlar el flujo de informaciÃ³n entre ellos.  
