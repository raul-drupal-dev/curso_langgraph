# ğŸ› ï¸ Tema 7: Tools â€“ IntegraciÃ³n de Herramientas Externas en el Grafo  

## ğŸš€ Â¿QuÃ© son las Tools en LangGraph?  

Las **tools (herramientas)** son funciones externas que el grafo puede invocar para realizar tareas especÃ­ficas, como consultas a bases de datos, cÃ¡lculos matemÃ¡ticos o llamadas a APIs externas.  
Las tools permiten que el grafo **extienda sus capacidades mÃ¡s allÃ¡ de los nodos internos**, integrando lÃ³gica personalizada o servicios de terceros.  

---

### ğŸ§  Â¿Por quÃ© son Importantes las Tools?  

- **Extensibilidad:** Permiten que el grafo interactÃºe con APIs externas y sistemas avanzados.  
- **Modularidad:** Las tools se definen de forma independiente y se integran fÃ¡cilmente en el flujo del grafo.  
- **Eficiencia:** Delegan tareas especÃ­ficas a funciones externas, reduciendo la complejidad dentro de los nodos.  

ğŸ‘‰ **Piensa en las tools como plugins** que aÃ±aden nuevas capacidades al grafo sin necesidad de modificar su estructura central.  

---

## âš™ï¸ Â¿CÃ³mo Funcionan las Tools?  

1. **DefiniciÃ³n de Tools:** Creamos funciones externas que pueden recibir parÃ¡metros y devolver resultados.  
2. **VinculaciÃ³n al Modelo de Lenguaje (LLM):** Asociamos estas tools al LLM para que pueda invocarlas durante el flujo de trabajo.  
3. **EjecuciÃ³n Condicional:** Si el LLM detecta que es necesario usar una tool, el grafo redirige el flujo para ejecutarla y procesar el resultado.  

ğŸ’¡ Es importante entender que es **el LLM quien decide que tool invocar** dependiendo del prompt que hayamos generado.

---

## ğŸ“‹ Ejemplo PrÃ¡ctico: Chatbot con Tools para Soporte y Ventas  

Vamos a construir un grafo que actÃºa como un asistente virtual, redirigiendo solicitudes de los usuarios a diferentes herramientas segÃºn sus necesidades.  
El chatbot podrÃ¡:  
1. **Consultar precios de productos.**  
2. **Verificar el estado de pedidos.**  
3. **Abrir tickets de soporte.**  

```python
from langchain_openai import ChatOpenAI

# Definimos las tools externas
def check_price(product: str) -> str:
    return f"El precio de {product} es de 100â‚¬."

def order_status(order_id: int) -> str:
    return f"El pedido con ID {order_id} estÃ¡ en camino."

def open_ticket(issue: str) -> str:
    return f"Se ha abierto un ticket de soporte para el problema: {issue}."

tools = [check_price, order_status, open_ticket]

# Vinculamos las tools al modelo de lenguaje
llm = ChatOpenAI(model="gpt-4o")
llm_with_tools = llm.bind_tools(tools, parallel_tool_calls=False)
```

---

### ğŸ” ExplicaciÃ³n del Ejemplo:  

- **Tools (`check_price`, `order_status`, `open_ticket`):** Simulan herramientas externas que realizan distintas tareas para ventas y soporte.  
- **Assistant Node:** El nodo principal procesa el mensaje del usuario y decide si debe invocar alguna tool.  
- **Router Condicional:** El flujo se redirige al nodo de tools si se detecta una llamada a alguna de ellas.  

---

## ğŸ—ï¸ ConstrucciÃ³n del Grafo  

Creamos los nodos y edges necesarios para integrar las tools al flujo del grafo.  
[codigo2]  
```python
from langgraph.graph import MessagesState
from langchain_core.messages import HumanMessage, SystemMessage

sys_msg = SystemMessage(content="Eres un asistente de ventas y soporte. Responde usando las herramientas disponibles.")

def assistant(state: MessagesState):
    return {"messages": [llm_with_tools.invoke([sys_msg] + state["messages"])]}

from langgraph.graph import START, StateGraph
from langgraph.prebuilt import tools_condition
from langgraph.prebuilt import ToolNode

builder = StateGraph(MessagesState)

# AÃ±adimos nodos
builder.add_node("assistant", assistant)
builder.add_node("tools", ToolNode(tools))

# Definimos los edges y el flujo del grafo
builder.add_edge(START, "assistant")
builder.add_conditional_edges("assistant", tools_condition)
builder.add_edge("tools", "assistant")

graph_with_tools = builder.compile()
```

---

## ğŸš€ Invocando el Grafo  

Probamos el grafo enviando un mensaje del usuario para ver cÃ³mo se invocan las tools en el flujo.  

```python
from IPython.display import Image, display
display(Image(graph_with_tools.get_graph(xray=True).draw_mermaid_png()))

messages = [HumanMessage(content="Quiero saber el precio del producto X y abrir un ticket de soporte.")]
response = graph_with_tools.invoke({"messages": messages})

for msg in response["messages"]:
    print(msg.content)
```

```python
El precio de producto X es de 100â‚¬.
Se ha abierto un ticket de soporte para el problema: Precio de producto X.
```

El chatbot analiza la solicitud, invoca las tools adecuadas y devuelve una respuesta consolidada al usuario.  

---

## ğŸ§‘â€ğŸ« Â¿QuÃ© Hemos Aprendido?  

- **Tools:** Permiten extender el grafo con funciones externas que realizan tareas especÃ­ficas.  
- **IntegraciÃ³n con LLM:** Las tools se vinculan directamente al modelo de lenguaje, permitiendo respuestas mÃ¡s avanzadas.  
- **Flujo DinÃ¡mico:** El grafo puede invocar tools de forma condicional, adaptÃ¡ndose a las necesidades del usuario.  

---

## ğŸŒ Â¿QuÃ© es lo Siguiente?  

En el prÃ³ximo tema, profundizaremos en **subgrafos (subgraphs)**, permitiendo que el grafo ejecute flujos complejos de manera modular y jerÃ¡rquica.  
