# ğŸ§© Tema 3: State Schema y Memoria  

## ğŸš€ Â¿QuÃ© es el State Schema y la Memoria en LangGraph?  

El **State Schema** es una parte fundamental de LangGraph que nos permite definir y gestionar el estado del grafo mientras se ejecuta.  
El estado es la informaciÃ³n que se **mantiene, actualiza y transfiere** a medida que el flujo pasa por diferentes nodos.  

La memoria nos permite:  
- **Persistencia de datos** a lo largo del flujo.  
- **Decisiones basadas en el estado actual**.  
- **Mayor control** sobre cÃ³mo se modifica la informaciÃ³n.  

Piensa en el estado como una mochila que lleva informaciÃ³n de un nodo a otro, y en cada nodo puedes **aÃ±adir, modificar o eliminar** elementos dentro de esa mochila.  

---

## ğŸ› ï¸ Ejemplo PrÃ¡ctico: Implementando State Schema y Memoria  

A continuaciÃ³n, construiremos un ejemplo simple que muestra cÃ³mo definir un `State Schema` y cÃ³mo los nodos modifican el estado paso a paso.  

### ğŸ“‹ DefiniciÃ³n del State Schema  
Primero, creamos una estructura bÃ¡sica para nuestro estado utilizando `TypedDict`.  
[codigo1]  

---

### ğŸ§© CreaciÃ³n de Nodos para Modificar el Estado  
Definimos tres nodos:  
- **Nodo 1**: AÃ±ade `"Estoy aprendiendo"` al estado.  
- **Nodo 2**: Agrega `" LangGraph!"`.  
- **Nodo 3**: AÃ±ade `" Python es increÃ­ble!"` en funciÃ³n de una decisiÃ³n aleatoria.  

Cada nodo toma el estado actual y lo modifica segÃºn una lÃ³gica simple.  
[codigo2]  

---

### ğŸ”„ DecisiÃ³n Condicional  
Implementamos una funciÃ³n que decide entre el **Nodo 2** o el **Nodo 3**, aÃ±adiendo una bifurcaciÃ³n condicional.  
[codigo3]  

---

### ğŸ—ï¸ ConstrucciÃ³n del Grafo  
Agregamos los nodos y edges necesarios para construir el grafo, conectando `START` con `node_1`, seguido de una bifurcaciÃ³n hacia `node_2` o `node_3`, y terminando en `END`.  
[codigo4]  

---

### ğŸ“ˆ VisualizaciÃ³n del Grafo  
Para entender mejor la estructura creada, visualizamos el grafo.  
[codigo5]  

---

## ğŸš€ Invocando el Grafo y Posibles Resultados  

Invocamos el grafo pasando un estado inicial.  

```python
graph.invoke({"graph_state" : "Hola!"})
````

Dependiendo de la bifurcaciÃ³n, podemos obtener diferentes resultados:

```phyton title="Resultado 1"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. Me gusta programar!'}
```
```phyton title="Resultado 2"
---Node 1---
---Node 3---
{'graph_state': 'Hola, me llamo Raul. Me gusta salir en bici!'}
```

## ğŸ§© Â¿QuÃ© Hemos Aprendido?  

- **State Schema:** Define la estructura del estado que se mantiene a lo largo del flujo del grafo.  
- **Edges Condicionales:** Permiten bifurcaciones en el flujo, tomando decisiones dinÃ¡micas que afectan el camino que sigue el grafo.  
- **Flujo de Trabajo DinÃ¡mico:** Al conectar nodos de forma condicional, podemos crear grafos mÃ¡s complejos y adaptativos, generando diferentes resultados segÃºn la lÃ³gica aplicada.  
- **ConstrucciÃ³n de Grafos:** Hemos aprendido a agregar nodos, edges y compilar el grafo usando `StateGraph` y `add_edge`.  

---